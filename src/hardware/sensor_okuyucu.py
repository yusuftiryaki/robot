"""
üì° Sens√∂r Okuyucu - Robot'un Duyularƒ±  
Hacƒ± Abi'nin sens√∂r y√∂netimi burada!

Bu sƒ±nƒ±f robot'un t√ºm sens√∂rlerini okur:
- MPU-6050 IMU (ivme√∂l√ßer, jiroskop)
- GPS NEO-6M
- INA219 akƒ±m/voltaj sens√∂r√º
- √ñn tampon sens√∂r√º
- Ultrasonik sens√∂rler
"""

import asyncio
import logging
import time
import json
import math
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime


@dataclass
class IMUData:
    """IMU sens√∂r verisi"""
    accel_x: float
    accel_y: float
    accel_z: float
    gyro_x: float
    gyro_y: float
    gyro_z: float
    roll: float
    pitch: float
    yaw: float
    temperature: float


@dataclass
class GPSData:
    """GPS sens√∂r verisi"""
    latitude: float
    longitude: float
    altitude: float
    satellites: int
    fix_quality: int
    speed: float
    course: float
    timestamp: str


@dataclass
class PowerData:
    """G√º√ß sens√∂r verisi"""
    voltage: float
    current: float
    power: float
    level: float  # batarya seviyesi %


@dataclass
class UltrasonikData:
    """Ultrasonik sens√∂r verisi"""
    front: float
    left: float
    right: float
    back: float


class SensorOkuyucu:
    """
    üì° Ana Sens√∂r Okuyucu Sƒ±nƒ±fƒ±
    
    Robot'un t√ºm sens√∂rlerini okur ve verileri i≈üler.
    Sim√ºlasyon modunda sahte veriler √ºretir.
    """
    
    def __init__(self, sensor_config: Dict[str, Any]):
        self.config = sensor_config
        self.logger = logging.getLogger("SensorOkuyucu")
        
        # Sim√ºlasyon modu kontrol√º
        self.simulation_mode = self._is_simulation()
        
        # Sens√∂r durumlarƒ±
        self.sensors_aktif = False
        self.son_okuma_zamani = {}
        
        # Kalibrasyon verileri
        self.imu_kalibrasyon = {
            "accel_offset": {"x": 0, "y": 0, "z": 0},
            "gyro_offset": {"x": 0, "y": 0, "z": 0}
        }
        
        # Sim√ºlasyon verileri
        self.simulation_data = self._load_simulation_data()
        self.simulation_time_start = time.time()
        
        self.logger.info(f"üì° Sens√∂r okuyucu ba≈ülatƒ±ldƒ± (Sim√ºlasyon: {self.simulation_mode})")
        self._init_sensors()
    
    def _is_simulation(self) -> bool:
        """Sim√ºlasyon modunda mƒ± kontrol et"""
        try:
            import board
            return False
        except ImportError:
            return True
    
    def _load_simulation_data(self) -> Dict[str, Any]:
        """Sim√ºlasyon verilerini y√ºkle"""
        try:
            with open('.devcontainer/simulator_data/config.json', 'r') as f:
                data = json.load(f)
                return data.get('simulation_values', {})
        except FileNotFoundError:
            self.logger.warning("‚ö†Ô∏è Sim√ºlasyon verisi bulunamadƒ±, varsayƒ±lan deƒüerler kullanƒ±lƒ±yor")
            return {
                "battery_voltage": 12.5,
                "battery_current": 1.2,
                "gps_coordinates": {"lat": 39.9334, "lon": 32.8597},
                "imu_orientation": {"roll": 0, "pitch": 0, "yaw": 0}
            }
    
    def _init_sensors(self):
        """Sens√∂rleri ba≈ülat"""
        if self.simulation_mode:
            self._init_simulation_sensors()
        else:
            self._init_real_sensors()
    
    def _init_simulation_sensors(self):
        """Sim√ºlasyon sens√∂rlerini ba≈ülat"""
        self.logger.info("üîß Sim√ºlasyon sens√∂rleri ba≈ülatƒ±lƒ±yor...")
        self.sensors_aktif = True
        self.logger.info("‚úÖ Sim√ºlasyon sens√∂rleri hazƒ±r!")
    
    def _init_real_sensors(self):
        """Ger√ßek sens√∂rleri ba≈ülat"""
        self.logger.info("üîß Fiziksel sens√∂rler ba≈ülatƒ±lƒ±yor...")
        try:
            import board
            import busio
            import adafruit_mpu6050
            import adafruit_ina219
            import adafruit_gps
            import serial
            
            # I2C Bus
            i2c = busio.I2C(board.SCL, board.SDA)
            
            # MPU-6050 IMU
            self.mpu = adafruit_mpu6050.MPU6050(i2c)
            self.logger.info("‚úÖ MPU-6050 IMU ba≈ülatƒ±ldƒ±")
            
            # INA219 G√º√ß sens√∂r√º
            self.ina219 = adafruit_ina219.INA219(i2c)
            self.logger.info("‚úÖ INA219 g√º√ß sens√∂r√º ba≈ülatƒ±ldƒ±")
            
            # GPS UART
            uart = serial.Serial(
                "/dev/ttyS0",  # Raspberry Pi UART
                baudrate=9600,
                timeout=10
            )
            self.gps = adafruit_gps.GPS(uart, debug=False)
            self.gps.send_command(b"PMTK314,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0")
            self.gps.send_command(b"PMTK220,1000")
            self.logger.info("‚úÖ GPS NEO-6M ba≈ülatƒ±ldƒ±")
            
            # √ñn tampon sens√∂r√º
            import RPi.GPIO as GPIO
            self.tampon_pin = self.config.get("front_bumper", {}).get("pin", 16)
            GPIO.setup(self.tampon_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
            self.logger.info(f"‚úÖ √ñn tampon sens√∂r√º ba≈ülatƒ±ldƒ± (Pin {self.tampon_pin})")
            
            self.sensors_aktif = True
            self.logger.info("‚úÖ T√ºm fiziksel sens√∂rler hazƒ±r!")
            
        except Exception as e:
            self.logger.error(f"‚ùå Sens√∂r ba≈ülatma hatasƒ±: {e}")
            self.simulation_mode = True
            self._init_simulation_sensors()
    
    async def tum_verileri_oku(self) -> Dict[str, Any]:
        """
        üìä T√ºm sens√∂rlerden veri oku
        
        Returns:
            Dict: T√ºm sens√∂r verileri
        """
        if not self.sensors_aktif:
            return {}
        
        # Paralel olarak t√ºm sens√∂rleri oku
        tasks = [
            self.imu_oku(),
            self.gps_oku(),
            self.batarya_oku(),
            self.tampon_oku(),
            self.ultrasonik_oku()
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Sonu√ßlarƒ± birle≈ütir
        sensor_data = {
            "timestamp": datetime.now().isoformat(),
            "imu": results[0] if not isinstance(results[0], Exception) else None,
            "gps": results[1] if not isinstance(results[1], Exception) else None,
            "batarya": results[2] if not isinstance(results[2], Exception) else None,
            "tampon": results[3] if not isinstance(results[3], Exception) else None,
            "ultrasonik": results[4] if not isinstance(results[4], Exception) else None
        }
        
        # Hatalarƒ± logla
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                sensor_names = ["IMU", "GPS", "Batarya", "Tampon", "Ultrasonik"]
                self.logger.warning(f"‚ö†Ô∏è {sensor_names[i]} okuma hatasƒ±: {result}")
        
        return sensor_data
    
    async def imu_oku(self) -> Optional[Dict[str, Any]]:
        """üß≠ IMU sens√∂r√ºnden veri oku"""
        try:
            if self.simulation_mode:
                return await self._simulation_imu_oku()
            else:
                return await self._real_imu_oku()
        except Exception as e:
            self.logger.error(f"‚ùå IMU okuma hatasƒ±: {e}")
            return None
    
    async def _simulation_imu_oku(self) -> Dict[str, Any]:
        """Sim√ºlasyon IMU verisi"""
        # Zamanla biraz salƒ±nƒ±m ekle
        t = time.time() - self.simulation_time_start
        
        # Sim√ºlasyon deƒüerleri
        base_data = self.simulation_data.get("imu_orientation", {})
        
        imu_data = IMUData(
            accel_x=0.1 * math.sin(t * 0.5),
            accel_y=0.1 * math.cos(t * 0.3),
            accel_z=9.81 + 0.05 * math.sin(t),
            gyro_x=0.02 * math.sin(t * 0.8),
            gyro_y=0.02 * math.cos(t * 0.6),
            gyro_z=0.01 * math.sin(t * 0.4),
            roll=base_data.get("roll", 0) + 2 * math.sin(t * 0.2),
            pitch=base_data.get("pitch", 0) + 1 * math.cos(t * 0.3),
            yaw=base_data.get("yaw", 0) + 0.5 * t % 360,
            temperature=25.0 + 2 * math.sin(t * 0.1)
        )
        
        return asdict(imu_data)
    
    async def _real_imu_oku(self) -> Dict[str, Any]:
        """Ger√ßek IMU verisi"""
        # MPU-6050'den veri oku
        accel_x, accel_y, accel_z = self.mpu.acceleration
        gyro_x, gyro_y, gyro_z = self.mpu.gyro
        temp = self.mpu.temperature
        
        # Kalibrasyon uygula
        accel_x -= self.imu_kalibrasyon["accel_offset"]["x"]
        accel_y -= self.imu_kalibrasyon["accel_offset"]["y"]
        accel_z -= self.imu_kalibrasyon["accel_offset"]["z"]
        
        gyro_x -= self.imu_kalibrasyon["gyro_offset"]["x"]
        gyro_y -= self.imu_kalibrasyon["gyro_offset"]["y"]
        gyro_z -= self.imu_kalibrasyon["gyro_offset"]["z"]
        
        # Roll, pitch, yaw hesapla
        roll = math.atan2(accel_y, accel_z) * 180 / math.pi
        pitch = math.atan2(-accel_x, math.sqrt(accel_y**2 + accel_z**2)) * 180 / math.pi
        yaw = 0.0  # Magnetometre olmadƒ±ƒüƒ± i√ßin yaw hesaplanamƒ±yor
        
        imu_data = IMUData(
            accel_x=accel_x,
            accel_y=accel_y,
            accel_z=accel_z,
            gyro_x=gyro_x,
            gyro_y=gyro_y,
            gyro_z=gyro_z,
            roll=roll,
            pitch=pitch,
            yaw=yaw,
            temperature=temp
        )
        
        return asdict(imu_data)
    
    async def gps_oku(self) -> Optional[Dict[str, Any]]:
        """üó∫Ô∏è GPS sens√∂r√ºnden veri oku"""
        try:
            if self.simulation_mode:
                return await self._simulation_gps_oku()
            else:
                return await self._real_gps_oku()
        except Exception as e:
            self.logger.error(f"‚ùå GPS okuma hatasƒ±: {e}")
            return None
    
    async def _simulation_gps_oku(self) -> Dict[str, Any]:
        """Sim√ºlasyon GPS verisi"""
        base_coords = self.simulation_data.get("gps_coordinates", {})
        t = time.time() - self.simulation_time_start
        
        # Rastgele hareket sim√ºlasyonu
        lat_offset = 0.0001 * math.sin(t * 0.1)
        lon_offset = 0.0001 * math.cos(t * 0.1)
        
        gps_data = GPSData(
            latitude=base_coords.get("lat", 39.9334) + lat_offset,
            longitude=base_coords.get("lon", 32.8597) + lon_offset,
            altitude=850.0 + 5 * math.sin(t * 0.05),
            satellites=8,
            fix_quality=1,
            speed=0.5 + 0.2 * math.sin(t * 0.3),
            course=45.0 + 10 * math.sin(t * 0.2),
            timestamp=datetime.now().isoformat()
        )
        
        return asdict(gps_data)
    
    async def _real_gps_oku(self) -> Dict[str, Any]:
        """Ger√ßek GPS verisi"""
        self.gps.update()
        
        if not self.gps.has_fix:
            return {
                "latitude": 0.0,
                "longitude": 0.0,
                "altitude": 0.0,
                "satellites": self.gps.satellites,
                "fix_quality": 0,
                "speed": 0.0,
                "course": 0.0,
                "timestamp": datetime.now().isoformat()
            }
        
        gps_data = GPSData(
            latitude=self.gps.latitude,
            longitude=self.gps.longitude,
            altitude=self.gps.altitude_m or 0.0,
            satellites=self.gps.satellites or 0,
            fix_quality=self.gps.fix_quality or 0,
            speed=self.gps.speed_knots or 0.0,
            course=self.gps.track_angle_deg or 0.0,
            timestamp=datetime.now().isoformat()
        )
        
        return asdict(gps_data)
    
    async def batarya_oku(self) -> Optional[Dict[str, Any]]:
        """üîã Batarya sens√∂r√ºnden veri oku"""
        try:
            if self.simulation_mode:
                return await self._simulation_batarya_oku()
            else:
                return await self._real_batarya_oku()
        except Exception as e:
            self.logger.error(f"‚ùå Batarya okuma hatasƒ±: {e}")
            return None
    
    async def _simulation_batarya_oku(self) -> Dict[str, Any]:
        """Sim√ºlasyon batarya verisi"""
        t = time.time() - self.simulation_time_start
        
        # Batarya yava≈ü yava≈ü azalƒ±r
        base_voltage = self.simulation_data.get("battery_voltage", 12.5)
        base_current = self.simulation_data.get("battery_current", 1.2)
        
        # Batarya seviyesi zamanla azalƒ±r
        discharge_rate = 0.001  # %0.1 per dakika
        level = max(20.0, 100.0 - (t / 60) * discharge_rate)
        
        voltage = base_voltage * (level / 100) + 0.1 * math.sin(t * 0.2)
        current = base_current + 0.3 * math.sin(t * 0.5)
        
        power_data = PowerData(
            voltage=voltage,
            current=current,
            power=voltage * current,
            level=level
        )
        
        return asdict(power_data)
    
    async def _real_batarya_oku(self) -> Dict[str, Any]:
        """Ger√ßek batarya verisi"""
        bus_voltage = self.ina219.bus_voltage
        shunt_voltage = self.ina219.shunt_voltage
        current = self.ina219.current / 1000  # mA to A
        power = self.ina219.power / 1000  # mW to W
        
        # Batarya seviyesi tahmin et (12V sistemi i√ßin)
        voltage = bus_voltage + shunt_voltage
        level = max(0, min(100, (voltage - 10.5) / (12.6 - 10.5) * 100))
        
        power_data = PowerData(
            voltage=voltage,
            current=current,
            power=power,
            level=level
        )
        
        return asdict(power_data)
    
    async def tampon_oku(self) -> Dict[str, bool]:
        """üöß √ñn tampon sens√∂r√º oku"""
        try:
            if self.simulation_mode:
                # Sim√ºlasyonda bazen engel var
                t = time.time()
                engel_var = (int(t) % 10) == 0  # Her 10 saniyede bir engel
                return {"front_bumper": engel_var}
            else:
                import RPi.GPIO as GPIO
                # Pull-up resistor kullanƒ±ldƒ±ƒüƒ± i√ßin False = basƒ±lƒ±
                basili = not GPIO.input(self.tampon_pin)
                return {"front_bumper": basili}
        except Exception as e:
            self.logger.error(f"‚ùå Tampon okuma hatasƒ±: {e}")
            return {"front_bumper": False}
    
    async def ultrasonik_oku(self) -> Optional[Dict[str, Any]]:
        """üìè Ultrasonik sens√∂rlerden mesafe oku"""
        try:
            if self.simulation_mode:
                return await self._simulation_ultrasonik_oku()
            else:
                return await self._real_ultrasonik_oku()
        except Exception as e:
            self.logger.error(f"‚ùå Ultrasonik okuma hatasƒ±: {e}")
            return None
    
    async def _simulation_ultrasonik_oku(self) -> Dict[str, Any]:
        """Sim√ºlasyon ultrasonik verisi"""
        t = time.time() - self.simulation_time_start
        
        # Rastgele engel mesafeleri
        ultrasonik_data = UltrasonikData(
            front=2.0 + 0.5 * math.sin(t * 0.3),
            left=1.5 + 0.3 * math.cos(t * 0.4),
            right=1.8 + 0.4 * math.sin(t * 0.2),
            back=3.0 + 0.2 * math.cos(t * 0.1)
        )
        
        return asdict(ultrasonik_data)
    
    async def _real_ultrasonik_oku(self) -> Dict[str, Any]:
        """Ger√ßek ultrasonik verisi"""
        # Bu fonksiyon ultrasonik sens√∂r baƒülandƒ±ƒüƒ±nda tamamlanacak
        # ≈ûimdilik sim√ºlasyon verisi d√∂n
        return await self._simulation_ultrasonik_oku()
    
    async def kalibrasyon_yap(self):
        """üéØ Sens√∂r kalibrasyonu yap"""
        self.logger.info("üéØ Sens√∂r kalibrasyonu ba≈ülatƒ±lƒ±yor...")
        
        if self.simulation_mode:
            self.logger.info("‚úÖ Sim√ºlasyon kalibrasyonu tamamlandƒ±")
            return
        
        try:
            # IMU kalibrasyonu i√ßin 100 √∂rnek al
            accel_sum = {"x": 0, "y": 0, "z": 0}
            gyro_sum = {"x": 0, "y": 0, "z": 0}
            
            samples = 100
            for i in range(samples):
                accel_x, accel_y, accel_z = self.mpu.acceleration
                gyro_x, gyro_y, gyro_z = self.mpu.gyro
                
                accel_sum["x"] += accel_x
                accel_sum["y"] += accel_y
                accel_sum["z"] += accel_z - 9.81  # Gravity compensation
                
                gyro_sum["x"] += gyro_x
                gyro_sum["y"] += gyro_y
                gyro_sum["z"] += gyro_z
                
                await asyncio.sleep(0.01)  # 10ms bekleme
            
            # Ortalama hesapla
            self.imu_kalibrasyon["accel_offset"] = {
                "x": accel_sum["x"] / samples,
                "y": accel_sum["y"] / samples,
                "z": accel_sum["z"] / samples
            }
            self.imu_kalibrasyon["gyro_offset"] = {
                "x": gyro_sum["x"] / samples,
                "y": gyro_sum["y"] / samples,
                "z": gyro_sum["z"] / samples
            }
            
            self.logger.info("‚úÖ IMU kalibrasyonu tamamlandƒ±")
            self.logger.info(f"üìä Accel offset: {self.imu_kalibrasyon['accel_offset']}")
            self.logger.info(f"üìä Gyro offset: {self.imu_kalibrasyon['gyro_offset']}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Kalibrasyon hatasƒ±: {e}")
    
    def get_sensor_durumu(self) -> Dict[str, Any]:
        """Sens√∂r durumu bilgisi"""
        return {
            "aktif": self.sensors_aktif,
            "sim√ºlasyon": self.simulation_mode,
            "kalibrasyon": self.imu_kalibrasyon,
            "son_okuma": self.son_okuma_zamani.copy()
        }
    
    def __del__(self):
        """Sens√∂r okuyucu kapatƒ±lƒ±yor"""
        if hasattr(self, 'logger'):
            self.logger.info("üëã Sens√∂r okuyucu kapatƒ±lƒ±yor...")
        
        if not self.simulation_mode:
            try:
                import RPi.GPIO as GPIO
                GPIO.cleanup()
            except:
                pass
